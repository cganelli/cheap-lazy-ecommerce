# Cheap & Lazy Stuff — Engineering Guide (CLAUDE.md)

## 0 — Purpose
Build a **fast, stable, simple** storefront. The live site is a **static Next.js export** deployed to Netlify. Products and images are prepared **at build time**. We avoid runtime APIs/DBs unless explicitly enabled via a feature flag.

- **MUST** rules are enforced by CI/review.
- **SHOULD** rules are strongly recommended.

---

## 1 — Before Coding
- **BP-1 (MUST)** Clarify requirements when needed, but **don’t block** during incidents. If something’s ambiguous, **state assumptions** and ship the **smallest safe change** with evidence.
- **BP-2 (SHOULD)** For non-trivial work, include a 5-line approach in the PR (goal, constraints, alternatives considered).
- **BP-3 (SHOULD)** If ≥2 approaches exist, list pros/cons and choose the **least complex** that meets the goal.

---

## 2 — While Coding
- **C-1 (MUST)** Keep the site **API-free/static** by default. Load products from `data/products.optimized.json` at build/render time (no runtime fetch to `/api/*`).
- **C-2 (MUST)** Product images: fixed-aspect wrapper (e.g., `aspect-[4/5]`) + `object-contain` to avoid stretching/CLS.
- **C-3 (MUST)** Use responsive images (`srcset` + `sizes`) from the optimized catalog. Prefer local WebP thumbnails.
- **C-4 (MUST)** Maintain explicit types; use `import type { … }` for type-only imports.
- **C-5 (SHOULD NOT)** Introduce classes when small composable functions suffice.
- **C-6 (SHOULD)** Default to `type`; use `interface` only when merging or readability improves.
- **C-7 (SHOULD NOT)** Add comments for obvious code; comment only caveats/tradeoffs.
- **C-8 (SHOULD)** Consider a branded `type Asin = Brand<string,'ASIN'>` if it prevents mix-ups; otherwise keep simple types.

---

## 3 — Testing
- **T-1 (MUST)** Unit-test pure logic (helpers like search ranking, price parsing, category normalization) in colocated `*.spec.ts`.
- **T-2 (SHOULD)** Prefer integration tests for rendering utilities (e.g., image component emits correct `srcset`).
- **T-3 (SHOULD)** Use property-based tests where useful (idempotent parsing, ascending `srcset`).
- **T-4 (MUST)** Keep tests pragmatic for build tools (image pipeline): assert outputs exist and are well-formed.

---

## 4 — Debugging Protocol (Evidence-First)
Use these **copy/paste** probes and include their output in PRs/issues.

**Netlify reachability**
```bash
curl --http1.1 -I -m 10 https://<site> | sed -n '1,30p'
curl --http1.1 -I -m 10 https://<sub>.netlify.app | sed -n '1,30p'
```

**Static file check**
```bash
curl --http1.1 -I -m 10 https://<site>/api/products.json
```

**Local static export sanity**
```bash
npm run build && npx http-server out -p 4321
```

**Catalog integrity**
```bash
jq '.items | length' data/products.optimized.json
jq '.items[0]' data/products.optimized.json
```

**Runtime API guard (should be none)**
```bash
grep -Rni "fetch('/api/products'" src || echo "No runtime API calls (good)"
```

---

## 5 — Data & Assets
- **D-1 (MUST)** **Source catalog:** `data/products.json` (human-edited or CSV-generated).
- **D-2 (MUST)** **Optimized catalog:** `data/products.optimized.json` (generated by image script; adds `image_srcset`, `image_blur`, `image_ratio`).
- **D-3 (MUST)** **Optimized images:** `public/products/<base>-<width>.webp` (e.g., `B0F7LSKLTZ-400.webp`, `-800.webp`).
- **D-4 (SHOULD)** Categories can be free-form in data; UI may normalize or just display as provided.
- **D-5 (SHOULD)** Keep prices as numbers where possible; tolerate string input but normalize on load.

---

## 6 — Image Optimization Pipeline (Static, Zero-API)
**Script:** `scripts/build-images.mjs` (Node + `sharp`).

**What it does**
- Downloads/reads each product image (`image_url` can be remote or local).
- Generates WebP thumbnails at widths: **400w, 800w** (add 1200w later if needed).
- Emits `public/products/*.webp` and writes `data/products.optimized.json` with:
  - `image_url` → local largest WebP
  - `image_srcset` → `"…-400.webp 400w, …-800.webp 800w"`
  - `image_blur` → tiny base64 preview
  - `image_ratio` → `width/height` of the source

**Run when catalog or images change**
```bash
npm run img:build
```

**package.json**
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build && next export -o out",
    "img:build": "node scripts/build-images.mjs",
    "img:clean": "rm -f public/products/*.webp"
  },
  "devDependencies": {
    "sharp": "^0.33.0"
  }
}
```

---

## 7 — Frontend (Next.js 15, Static Export)
- **F-1 (MUST)** `package.json`:
  ```json
  "build": "next build && next export -o out"
  ```
- **F-2 (MUST)** Load products at build/render time:
  ```ts
  import catalog from '@/../data/products.optimized.json';
  const items = (catalog as any).items ?? [];
  ```
- **F-3 (MUST)** Product image component (portrait-friendly, no CLS):
  ```tsx
  export function ProductCardImage({
    src, srcSet, alt, blur, ratio = 4 / 5, // 4:5 portrait default
  }: {
    src: string; srcSet?: string; alt: string; blur?: string; ratio?: number;
  }) {
    return (
      <div className="relative w-full overflow-hidden rounded-md bg-white" style={{ aspectRatio: String(ratio) }}>
        <img
          src={src}
          srcSet={srcSet}
          sizes="(min-width:1024px) 220px, (min-width:640px) 33vw, 50vw"
          alt={alt}
          loading="lazy"
          decoding="async"
          className="absolute inset-0 h-full w-full object-contain"
          width={800}
          height={1000}
          style={blur ? { backgroundImage: `url(${blur})`, backgroundRepeat: 'no-repeat', backgroundSize: 'cover' } : undefined}
        />
      </div>
    );
  }
  ```
  When mapping items:
  ```tsx
  <ProductCardImage
    src={p.image_url}
    srcSet={p.image_srcset}
    alt={p.title}
    blur={p.image_blur}
    ratio={p.image_ratio && isFinite(p.image_ratio) ? p.image_ratio : 4/5}
  />
  ```
- **F-4 (SHOULD)** Only the hero uses `fetchpriority="high"` (or `priority` with `next/image`).
- **F-5 (SHOULD)** Client-side search lives at `/search` (Fuse.js on the optimized catalog).

---

## 8 — Performance
- **P-1 (MUST)** Use local WebP thumbnails with `srcset` (400w, 800w).
- **P-2 (MUST)** No CLS on tiles: fixed aspect container + width/height on `<img>`.
- **P-3 (SHOULD)** Lazy-render long lists; keep ≤12 tiles per lane above the fold.
- **P-4 (SHOULD)** Preconnect/DNS-prefetch only for any remaining external image hosts.

---

## 9 — Build & Deploy (Netlify)
- **B-1 (MUST)** `netlify.toml` → `publish = "out"`. No functions or edge handlers by default.
- **B-2 (MUST)** Keep **Auto Publishing locked**. After each merge to `main`, manually click **Publish deploy** to make it live.
- **B-3 (SHOULD)** Tag releases (e.g., `v0.1.0-static-catalog`) so rollback is one click.
- **B-4 (SHOULD NOT)** Add Netlify Functions/Edge unless there is a clear, tested need.

---

## 10 — Git & Releases
- **GH-1 (MUST)** Use **Conventional Commits**: `feat: …`, `fix: …`, `perf: …`, etc.
- **GH-2 (SHOULD NOT)** Mention AI tools/vendors in commit messages.
- **Rel-1 (MUST)** Create annotated tags for production releases:
  ```bash
  git tag -a vX.Y.Z -m "release notes"
  git push origin vX.Y.Z
  ```
- **PR Flow (SHOULD)** Work on branches; open a PR; review + Deploy Preview; **merge**; then **Publish deploy** (manual).

---

## 11 — Tooling Gates
- **G-1 (MUST)** `prettier --check` passes.
- **G-2 (MUST)** `npm run lint && npm run typecheck` (or turbo equivalent) passes.
- **G-3 (MUST)** `npm run build` succeeds and emits `out/`.
- **G-4 (MUST)** If `data/products.json` changed, `npm run img:build` ran and updated `data/products.optimized.json`.

---

## 12 — Code Organization
```
data/
  products.json
  products.optimized.json
public/
  products/            # *.webp generated by img:build
scripts/
  build-images.mjs     # image optimizer
src/
  app/                 # routes (/, /search, etc.)
  components/          # ProductCardImage, etc.
  lib/                 # static-products.ts, search utils
```

---

## 13 — Writing Functions — Quick Checklist
1) Readability: can you follow it honestly?  
2) Avoid high cyclomatic complexity when possible.  
3) Prefer well-known data structures/algorithms if they clarify.  
4) No unused params; move casts to arguments where possible.  
5) Pure logic is testable without mocks.  
6) No hidden dependencies; pass values in.  
7) Consider 3 alternative names; pick the clearest.  
**Don’t** extract a function unless: it’s reused, it enables unit testing of otherwise untestable logic, or it drastically improves clarity.

---

## 14 — Writing Tests — Quick Checklist
1) Parameterize inputs; avoid magic literals.  
2) Don’t add trivial asserts.  
3) Test description must match the final `expect`.  
4) Compare to independent expectations, not the function’s own output.  
5) Tests follow the same lint/typing/style rules as prod code.  
6) Prefer invariants/property tests where they fit (e.g., idempotence).  
7) Group unit tests under `describe(fnName, …)`.  
8) Use `expect.any(...)` for variable parts.  
9) Prefer strong assertions (`toEqual(…)` over `>=`).  
10) Cover edge cases, realistic input, boundaries.  
11) Don’t test what the type system already guarantees.

---

## 15 — Shortcuts (you may see these in issues/PRs)
- **QNEW** — “Apply all MUST/SHOULD in CLAUDE.md to new work.”  
- **QPLAN** — “Explain plan; ensure it fits static architecture; minimal changes; reuse code.”  
- **QCODE** — “Implement; run tests; `prettier`; `lint`/`typecheck`; **build**.”  
- **QCHECK** — “Skeptical review vs. sections 13/14 + Implementation rules.”  
- **QCHECKF/QCHECKT** — “Deep review for functions/tests respectively.”  
- **QUX** — “List UX scenarios to test, in priority order.”  
- **QGIT** — “Stage, conventional commit, push (no AI mentions).”

---

## Appendix — API Readiness (Amazon Product Advertising API)

**Default (today):** static site; products from `data/products.optimized.json`.  
**Future goal:** optionally fetch live data via a Netlify Function with **cache + timeout + fallback**. The **schema stays the same** (`{ items: [...] }`), so the UI doesn’t change.

### Flags & Env (MUST)
- `USE_API` (default `false`) — feature flag to enable PA-API reads.
- `AMZN_ACCESS_KEY`, `AMZN_SECRET_KEY`, `AMZN_PARTNER_TAG`, `AMZN_PARTNER_TYPE`.
- `API_TIMEOUT_MS` (e.g., `800`), `API_CACHE_TTL_S` (e.g., `900`), `API_STALE_TTL_S` (e.g., `86400`).

### Data Flow (MUST)
1. **Client never calls PA-API.** Only a **Netlify Function** does (keeps keys private).
2. Function fetches PA-API → **normalizes** into our schema → caches.
3. UI consumes the same schema. If API times out or flag is off, **fallback to static**.

### Netlify (when enabling)
```toml
[build]
  command = "npm run build"
  publish = "out"

[functions]
  directory = "netlify/functions"

# Enable this redirect only when USE_API=true in production:
# [[redirects]]
#   from = "/api/products"
#   to = "/.netlify/functions/products"
#   status = 200
#   force = true
```

### Function Skeleton (timeout, cache, fallback)
`netlify/functions/products.ts`
```ts
import type { Handler } from '@netlify/functions';

const TIMEOUT = Number(process.env.API_TIMEOUT_MS ?? 800);
const TTL = Number(process.env.API_CACHE_TTL_S ?? 900);

async function fetchPAAPI(/* asins or query */): Promise<any[]> {
  // sign and call PA-API with AbortController timeout
  // normalize to { asin, title, price, image_url, category, affiliate_url }
  return [];
}

export const handler: Handler = async () => {
  // 1) try cache (KV/Blobs/etc.) — omitted here, choose a store
  // if (cached) return ok(cached);

  try {
    const items = await fetchPAAPI();
    // write cache with TTL
    return ok({ items });
  } catch {
    // fallback to stale cache if available
    // if (stale) return ok(stale);

    // final fallback: static file in the bundle
    const staticData = await import('../../data/products.optimized.json');
    const body = (staticData as any).default ?? staticData;
    return ok(body);
  }
};

function ok(body: unknown) {
  return {
    statusCode: 200,
    headers: {
      'content-type': 'application/json',
      'cache-control': 'public, max-age=60'
    },
    body: JSON.stringify(body)
  };
}
```

### Compliance (MUST)
- Don’t permanently store PA-API images if policy forbids; prefer their provided URLs when `USE_API=true`. Keep local WebP pipeline for non-Amazon sources.
- Respect PA-API freshness requirements (use TTLs; consider scheduled refresh if needed).

### Observability (SHOULD)
- Log request id, timeout, cache hit/miss, item count (no secrets).
- Add `/api/health` returning function status + cache age.

### Testing (MUST)
- Contract tests for **normalization** (PA-API → our schema).
- Integration test: **returns within TIMEOUT** or falls back to static.

### Rollout Plan (MUST)
1. Merge function scaffold + flags behind `USE_API=false`.
2. Enable in **Preview** with `USE_API=true`; verify latency, headers, cache.
3. (Optional) Dual-read in preview; log diffs vs static.
4. Flip `USE_API=true` in **production env**, then enable the redirect.
5. Keep the **static fallback** permanently (circuit breaker).
